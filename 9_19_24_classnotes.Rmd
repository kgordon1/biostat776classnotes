---
title: "9_19_24"
author: "Kate Gordon"
date: "2024-09-19"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

#which column gets recycled?

library("tibble")
tibble(
a = 1:5,
b = 6:10, 
c = 1, 
z = (a+b)^z +c
)

#What is length of y? 10
#rnorm generates random numbers from a normal distribution

set.seed(20240919)
data.frame(
x = 1:10, 
y = rnorm(10), 
in_group = c(TRUE, FALSE)
)

#Will this work?  True False True False
# How will in_group look like?

set.seed(20240919)
data.frame(
x = 1:10, 
y = rnorm(10), 
in_group = c(TRUE, FALSE, NA)
)

#in_group vector is 3
#recycling will not work here

# the error is: Error in data.frame(x = 1:10, y = rnorm(10), in_group = c(TRUE, FALSE,  : 
  #arguments imply differing number of rows: 10, 3
  



## ------------------------------------------------------------------------------------------------------------------------

Data Frames
Multiple lists of all the same length
Mix of vectors
Data frames are used to store tabular data in R. They are an important type of object in R and are used in a variety of statistical modeling applications. Hadley Wickham’s package dplyr has an optimized set of functions designed to work efficiently with data frames.

Data frames are represented as a special type of list where every element of the list has to have the same length.

```{r}
x <- data.frame(foo = 1:4, bar = c(T, T, F, F)) 
x
```

```{r}
attributes(x)
```
Data frames can be converted to a matrix by calling data.matrix(). While it might seem that the as.matrix() function should be used to coerce a data frame to a matrix, almost always, what you want is the result of data.matrix().
Converts columns to all of the same type of object

```{r}
data.matrix(x)
```

Transfers TRUE / FAlse into 1/0

Can just select integer columns and convert into a matrix


```{r}
attributes(data.matrix(x))
```
```{r}
x <- data.frame(foo = 1:4, bar = c(T, T, F, F),
                leo = 2:5)
data.matrix (x[, sapply(x, is.integer)])
x
```

Names
R objects can have names, which is very useful for writing readable code and self-describing objects.

Here is an example of assigning names to an integer vector.

```{r}
x <- 1:3
names(x)
```
```{r}
names(x) <- c("New York", "Seattle", "Los Angeles") 
x
```
Name of attribute Character name

```{r}
attributes(x)
```
Subset by name
```{r}
names(x) <- c("New York", "Seattle", "Los Angeles") 
x["Seattle"]
```


Lists can also have names, which is often very useful.

```{r}
x <- list("Los Angeles" = 1, Boston = 2, London = 3) 
x
```
Matrices can have both column and row names.

```{r}
m <- matrix(1:4, nrow = 2, ncol = 2)
dimnames(m) <- list(c("a", "b"), c("c", "d")) 
m
```
c("morning")

Column names and row names can be set separately using the colnames() and rownames() functions.

```{r}
colnames(m) <- c("h", "f")
rownames(m) <- c("x", "z")
m
```
DATA FRAME NAMES
For data frames, there is a separate function for setting the row names, the row.names() function.

Also, data frames do not have column names, they just have names (like lists).

So to set the column names of a data frame just use the names() function. Yes, I know its confusing.

Here’s a quick summary:

Object	Set column names	Set row names
data frame	names()	row.names()
matrix	colnames()	rownames()




## ------------------------------------------------------------------------------------------------------------------------

Control Structures
Control structures in R allow you to control the flow of execution of a series of R expressions.


if(<condition>) {
        ## do something
} 
## Continue with rest of code

The above code does nothing if the condition is false. If you have an action you want to execute when the condition is false, then you need an else clause.

if(<condition>) {
        ## do something
} 
else {
        ## do something else
}

You can have a series of tests by following the initial if with any number of else ifs.

if(<condition1>) {
        ## do something
} else if(<condition2>)  {
        ## do something different
} else {
        ## do something different
}
x <- runif(n = 1, min = 0, max = 10)
x


## Review %in% operator:
#it returns a vector with length equal to the 
# length of the left side vector to the %in%


```{r}
"b" %in% letters
```
```{r}
letters %in% "b" 
```
This gives a logical vector of length 26

Here is an example of a valid if/else structure.

Let’s use the runif(n, min=0, max=1) function which draws a random value between a min and max value with the default being between 0 and 1.

```{r}
x <- runif(n = 1, min = 0, max = 10)
x

```
Then, we can write and if-else statement that tests whethere x is greater than 3 or not.

```{r}
if (x > 3) {
    y <- 10
} else {
    y <- 0
}

y
```
```{r}
c("a". "ch", "b") %in% letters
ifelse(c("a", "ch", "b"))
```


This expression can also be written a different (but equivalent!) way in R.
```{r}
y <- if (x > 3) {
    10
} else {
    0
}

y
```

Of course, the else clause is not necessary. You could have a series of if clauses that always get executed if their respective conditions are true.

if(<condition1>) {

}

if(<condition2>) {

}




## ------------------------------------------------------------------------------------------------------------------------



## ------------------------------------------------------------------------------------------------------------------------
#| message: false
# try it yourself

library(tidyverse)
library(palmerpenguins)
penguins


## ------------------------------------------------------------------------------------------------------------------------

for Loops
For loops are pretty much the only looping construct that you will need in R. While you may occasionally find a need for other types of loops, in my experience doing data analysis, I’ve found very few situations where a for loop was not sufficient.

"For loop" has the most practical utility

In R, for loops take an iterator variable and assign it successive values from a sequence or vector.

For loops are most commonly used for iterating over the elements of an object (list, vector, etc.)

Syntax
for (i in 1:10) {
    print(i)
}

This "in" should not be confused with the %in%
```{r}
for (i in 1:10) {
    print(i)
  Sys.sleep(1)
}
```
```{r}
for (i in 1:10) {
  print(i)
  print(i^2)
  print(i^2+1)
}
```

This loop takes the i variable and in each iteration of the loop gives it values 1, 2, 3, …, 10, then executes the code within the curly braces, and then the loop exits.

The following three loops all have the same behavior.

```{r}
## define the loop to iterate over
x <- c("a", "b", "c", "d")

## create for loop
for (i in 1:4) {
    ## Print out each element of 'x'
    print(x[i])
}
```




## ------------------------------------------------------------------------------------------------------------------------

## ------------------------------------------------------------------------------------------------------------------------

We can also print just the iteration value (i) itself
```{r}
x
seq_along(x)

```

seq_along()
The seq_along() function is commonly used in conjunction with for loops in order to generate an integer sequence based on the length of an object (or ncol() of an R object) (in this case, the object x).

## ------------------------------------------------------------------------------------------------------------------------
## Generate a sequence based on length of 'x'
for (i in seq_along(x)) {
    print(x[i])
}

```{r}
## define the loop to iterate over
x <- c("a", "b", "c", "d")

## create for loop
for (i in 1:2) {
    ## Print out each element of 'x'
    print(x[i])
}
for (i in seq_along(x)) {
    print(x[i])
}
```
** Must use PRINT function to see output**

## ------------------------------------------------------------------------------------------------------------------------

```{r}
for (babyshark in x) {
    print(babyshark)
}
```

## ------------------------------------------------------------------------------------------------------------------------

```{r}
for (candyisgreat in x) {
    print(candyisgreat)
}
```

You can use any character index you want (but not with symbols or numbers).

```{r}
for (1999 in x) {
    print(1999)
}
```
## ----error=TRUE----------------------------------------------------------------------------------------------------------



## ------------------------------------------------------------------------------------------------------------------------
For one line loops, the curly braces are not strictly necessary.
```{r}

for (i in 1:4) print(x[i])
```

However, I like to use curly braces even for one-line loops, because that way if you decide to expand the loop to multiple lines, you won’t be burned because you forgot to add curly braces (and you will be burned by this).


## ------------------------------------------------------------------------------------------------------------------------
# try it yourself


## ------------------------------------------------------------------------------------------------------------------------

Nested for loops
for loops can be nested inside of each other.

```{r}
x <- matrix(1:6, nrow = 2, ncol = 3)
x
```
Printing the ith, j 
The j index goes across the columns. That’s why we values 1, 3, etc.

```{r}
for (i in seq_len(nrow(x))) {
    for (j in seq_len(ncol(x))) {
        print(x[i, j])
    }
}
```



## ------------------------------------------------------------------------------------------------------------------------



## ------------------------------------------------------------------------------------------------------------------------

while Loops
while loops begin by testing a condition.

If it is true, then they execute the loop body.

Once the loop body is executed, the condition is tested again, and so forth, until the condition is false, after which the loop exits.

Let's start with x = 0, while the count is <10, add 1 until you get to 9
```{r}
count <- 0
while (count < 10) {
    print(count)
    count <- count + 1
}
```
## ------------------------------------------------------------------------------------------------------------------------
z <- 5
set.seed(1)

while (z >= 3 && z <= 10) {
    coin <- rbinom(1, 1, 0.5)

    if (coin == 1) { ## random walk
        z <- z + 1
    } else {
        z <- z - 1
    }
}
print(z)


## ------------------------------------------------------------------------------------------------------------------------

repeat Loops
repeat initiates an infinite loop right from the start. These are not commonly used in statistical or data analysis applications, but they do have their uses.


IMPORTANT (READ THIS AND DON’T FORGET… I’M SERIOUS… YOU WANT TO REMEMBER THIS.. FOR REALZ PLZ REMEMBER THIS)
The only way to exit a repeat loop is to call **break**.


-2:2
((-2:2) >= 0) & ((-2:2) <= 0)


## ------------------------------------------------------------------------------------------------------------------------
(2 >= 0) && (-2 <= 0)
(-2 >= 0) && (-2 <= 0)


## ------------------------------------------------------------------------------------------------------------------------
```{r}
x0 <- 1
tol <- 1e-8

repeat {
    x1 <- computeEstimate()

    if (abs(x1 - x0) < tol) { ## Close enough?
        break
    } else {
        x0 <- x1
    }
}
```

#| eval: false
## x0 <- 1
## tol <- 1e-8
## 
## repeat {
##     x1 <- computeEstimate()
## 
##     if (abs(x1 - x0) < tol) { ## Close enough?
##         break
##     } else {
##         x0 <- x1
##     }
## }


## ----eval=FALSE,prompt=FALSE---------------------------------------------------------------------------------------------

**next, break**
next is used to skip an iteration of a loop.

```{r}
for (i in 1:100) {
    if (i <= 20) {
        ## Skip the first 20 iterations
        next
    }
    ## Do something here
}
```

break is used to exit a loop immediately, regardless of what iteration the loop may be on.

```{r}
for (i in 1:100) {
    print(i)

    if (i > 20) {
        ## Stop loop after 20 iterations
        break
    }
}
```
## ------------------------------------------------------------------------------------------------------------------------

Functions in R
Functions in R are “first class objects”, which means that they can be treated much like any other R object.

Your First Function
Functions are defined using the function() directive and are stored as R objects just like anything else.

In particular, functions are R objects of class function.

Here’s a simple function that takes no arguments and does nothing.

f <- function() {
    ## This is an empty function
}
## Functions have their own class
class(f)
## Execute this function
f()


Not very interesting, but it is a start!

The next thing we can do is create a function that actually has a non-trivial function body.
```{r}
f <- function() {
    # this is the function body
    hello <- "Hello, world!\n"
    cat(hello)  #print with cat function
}
f()

```

For loop vs function
with objects we create inside of a function, we cannot call the output it only exists within the function
## ------------------------------------------------------------------------------------------------------------------------


## ------------------------------------------------------------------------------------------------------------------------
hello <- "Hello, world!\n"

print(hello)
cat(hello)


## ------------------------------------------------------------------------------------------------------------------------
The last aspect of a basic function is the function arguments.

These are the options that you can specify to the user that the user may explicitly set.

For this basic function, we can add an argument that determines how many times “Hello, world!” is printed to the console.

```{r}
f <- function(num) {
    for (i in seq_len(num)) {
        hello <- "Hello, world!\n"
        cat(hello)
    }
}
f(3)
i # this "i" is not inside of the function!
```
**Use different names for variables or objects inside of the function that inside of the function**



## ------------------------------------------------------------------------------------------------------------------------

This next function returns the total number of characters printed to the console.

But often it is useful if a function returns something that perhaps can be fed into another section of code.
```{r}
f <- function(num) {
    hello <- "Hello, world!\n"
    for (i in seq_len(num)) {
        cat(hello)
    }
    chars <- nchar(hello) * num
    chars
}
meaningoflife <- f(3)
print(meaningoflife)
```
Save function of f into a new object meaning of life


Default values can be set

eg setting a default value of "1"

Any function argument can have a default value, if you wish to specify it.

Sometimes, argument values are rarely modified (except in special cases) and it makes sense to set a default value for that argument. This relieves the user from having to specify the value of that argument every single time the function is called.

Here, for example, we could set the default value for num to be 1, so that if the function is called without the num argument being explicitly specified, then it will print “Hello, world!” to the console once.

```{r}
f <- function(num = 1) {
    hello <- "Hello, world!\n"
    for (i in seq_len(num)) {
        cat(hello)
    }
    chars <- nchar(hello) * num  #times the number, in this case 1
    chars
}


f() ## Use default value for 'num'
```

## ------------------------------------------------------------------------------------------------------------------------
formals(f)


## ------------------------------------------------------------------------------------------------------------------------
f(num = 2)


## ------------------------------------------------------------------------------------------------------------------------
str(rnorm)
mydata <- rnorm(100, 2, 1) ## Generate some data


## ------------------------------------------------------------------------------------------------------------------------
## Positional match first argument, default for 'na.rm'
sd(mydata)
## Specify 'x' argument by name, default for 'na.rm'
sd(x = mydata)
## Specify both arguments by name
sd(x = mydata, na.rm = FALSE)


## ------------------------------------------------------------------------------------------------------------------------
## Specify both arguments by name
sd(na.rm = FALSE, x = mydata)


## ------------------------------------------------------------------------------------------------------------------------
sd(na.rm = FALSE, mydata)


## ------------------------------------------------------------------------------------------------------------------------
args(f)


## ------------------------------------------------------------------------------------------------------------------------
args(lm)


## ------------------------------------------------------------------------------------------------------------------------
f <- function(a, b) {
    a^2
}
f(2)


## ------------------------------------------------------------------------------------------------------------------------
#| error: true
f <- function(a, b) {
    print(a)
    print(b)
}
f(45)


## ------------------------------------------------------------------------------------------------------------------------
mean


## ------------------------------------------------------------------------------------------------------------------------
paste("one", "two", "three")
paste("one", "two", "three", "four", "five", sep = "_")


## ------------------------------------------------------------------------------------------------------------------------
args(paste)


## ------------------------------------------------------------------------------------------------------------------------
args(paste)


## ------------------------------------------------------------------------------------------------------------------------
paste("a", "b", sep = ":")


## ------------------------------------------------------------------------------------------------------------------------
paste("a", "b", se = ":")


## ------------------------------------------------------------------------------------------------------------------------
#| eval: false
## # Too short
## f()
## 
## # Not a verb, or descriptive
## my_awesome_function()
## 
## # Long, but clear
## impute_missing()
## collapse_years()


## ------------------------------------------------------------------------------------------------------------------------
# Never do this!
col_mins <- function(x, y) {}
rowMaxes <- function(x, y) {}


## ------------------------------------------------------------------------------------------------------------------------
#| eval: false
## # Good
## input_select()
## input_checkbox()
## input_text()
## 
## # Not so good
## select_input()
## checkbox_input()
## text_input()


## ------------------------------------------------------------------------------------------------------------------------
#| eval: false
## # Don't do this!
## T <- FALSE
## c <- 10
## mean <- function(x) sum(x)


## ------------------------------------------------------------------------------------------------------------------------
f <- function(x) {
    x + y
}


## ------------------------------------------------------------------------------------------------------------------------
y <- 100
f(10)

y <- 1000
f(10)


## ------------------------------------------------------------------------------------------------------------------------
`+` <- function(x, y) {
    if (runif(1) < 0.1) {
        sum(x, y)
    } else {
        sum(x, y) * 1.1
    }
}
table(replicate(1000, 1 + 2))


## ------------------------------------------------------------------------------------------------------------------------
rm(`+`)


## ------------------------------------------------------------------------------------------------------------------------
#| eval: false
## mean(is.na(x))
## 
## x / sum(x, na.rm = TRUE)


## ------------------------------------------------------------------------------------------------------------------------
options(width = 120)
sessioninfo::session_info()

## ------------------------------------------------------------------------------------------------------------------------
options(width = 120)
sessioninfo::session_info()


```{r}

```


